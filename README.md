# l
my new learn learn about c and c++
### 第一天 
  #### XOR的学习 xor_link
  XOR即异或运算，快速算法为不进位的加法运算，我从老师那里得知两个xor我使用技巧
  ** 第一个技巧：
  110^011=101 101^011=110 ，我们发现一个规律，如果a^b=c 那么 c^b=a 观察这两个式子，如果把a代入到第一个式子，会得到c^b^b=c，
  因为c与一个数进行运算等于本身，我们可以把b^b看成幺元，实际上，无论多少个相同的数进行xor运算都相当于幺元，如果a^b=N（N是一个未知的变量）
  那么如何求b，根据上面的结论，只需在a的左侧^a，后来我知道了异或运算是不先后顺序的，所以a可以在任意位置，所以b=N^a。进一步想一下，一个链表
  中有a,b,c三个数，只有a,b两个数被分配了地址，如果我们把c=a^b，将c也分配了地址，此时这三个数有一定的规律，知道其中两个数，可以快速得到第三数
  这是一个巨大的发现，因为我们可以根据地址快速找到第三个数的地址，这意味着这个链表可以任意方向的遍历，这就是异或链表。
  ** 第二个技巧：
  上面我们知道a^a^a...无论多少个a，都是幺元，我们可以快速查找到一堆数中的不同的数，并得到它的值
  #### 汇编内中断的学习 do0.asm
  ** 我学习王爽的汇编的内中断 我们来修改0号内中断程序的代码，该内中断为除0异常中断（但不是所有的中断都是异常），它触发了int + 编号 指令,编号是对应中断向量表中对应中断例程的内存地址，
      我们可以修改该内存地址的内容来达到修改中断例程的目的。下面我们来写一个0中断，有除0错误时，显示错误信息在屏幕上，这个程序叫do0
      *** 安装，写入内存，我们用到了rep movsb指令，该指令可以把代码放在特定的内存位置，该指令上面必须要有4个准备，1 设置 es:di 为目的地址， （es为段寄存
      中没有什么存在感的寄存器，di是有关堆栈的，它和si都没有什么存在感，是作为偏移地址，但重要的是，di,si,bx,bp,只能用这4个寄存器作偏移，bx是内存偏移，bp是堆栈偏移，用来代替sp取局
      部变量，di,si只在段偏移的时候见过）。2 设置 ds:si为源地址（ds是4个段寄存器之一，和内存有关，[]前面默认就是这个，要说的是，段寄存器隐藏很深，你读不到它的全貌，写也是修改其中一小部分
      3 设置cx 为传输长度 （cx和计数有关，但不要和程序计数器混淆，pc是记录的是下一条指令的地址，还有sepc是内核的程序计数器，在进行系统调用切换状态的时候，还有另一些有关内核的东西会用到），
      4 把传输方向改成正方向（不懂）用cld指令 进行完这四个操作后，执行rep movsb指令
      我们可以把想要的东西写入内存中了
      *** 设置中断向量表，将上面的内存地址写入向量表中，0号表项地址为0:0,0:0存放偏移地址，0:2存放段地址，相差2字节是因为地址是1字单元地址，但我不知道为什么先放偏移再放段地址。
      *** 将信息显示在屏幕上，mov ax,4c00h ax为4c00h时，再执行int 21h中断会将内容显示在屏幕上，这涉及到了显示器中断，将不同的寄存器存入对应的值会有不同的效果，比如说鼠标移动，
          在鼠标位置显示字符等等。
      *** do0 的取出字符串并显示在屏幕上，字符串上面要加短跳转，（短跳转一般用于循环，判断的跳转，这些距离都很短），跳到下面的正式代码，设置ds si，取出字符串，偏移要加2，
          （因为我们需要找到字符串，字符串上面有一行代码，要在目的地址加2，目的地址是我们上面写好的地址）,设置es:di，显示在屏幕上 设置字符串长度cx，然后写一个函数来循环取出字符串变量，
          显示在屏幕上 mov ax,4c00h  int 21h  
  #### c++的学习  无代码
    *** 我是看的黑马第32期淘宝视频，今天我看了两天的内容，是c++核心语法
        视频中的day1
        1. ::双冒号运算符 空代表全局变量  房子::
        2. using namespace + 房子名 这是编译  using 房子名::变量名 这是声明，声明会出错，与就近原则冲突
        3. namespace 不常用，因为我们一般不会写不同作用域的同一个名子的，但namespace{变量，类，结构体，函数} 可以定义不同的房子
        4. const c语言全局不可修改局部可间接修改 c++都不可修改 c是外部链接 c++是内部，想要在别的文件中调用要加extern提高作用域
                  const分配内存情况，const c = 1 存储在符号表内，是键值对，对他取地址会自动生成一个临时内存，
                  尽可能用const替代define
        5. 引用 变量类型&变量名=对象   本质是别名，是指针常量，所以要初始化，可以对数组有引用，int arr[10] int(&pArr)[10] =arr
        6.参数传递方式 值传递 地址传递 引用传递（本质是地址传递）
        7. 引用必须是一块合法的内存地址
            不能引用一个局部变量（函数的返回值）
            当函数返回值是引用时可以作为左值运算。
        8. 当指针遇上引用，二级指针就显得没那么重要了，
        9. 常量的引用 给引用加const修饰形参，可以达到防治修改形参的目的。
        视频的day2
        1. inline不是那么重要，编译器可以自动帮你加上或者删除，如果要用必须声明和实现都加在函数名前，内联函数有宏函数的优点：以空间换时间，堆栈上的局部变量都不用入栈出栈，因为是源代码替换
          内联函数也修复了宏函数缺陷，在适当的位置进行替换，防止出现1. 运算结合不对 2. 重复运算 a++执行两次，但我们希望它执行一次
        2.默认参数和占位参数 默认参数后面不能有一般参数 默认参数不能同时出现在函数声明与实现，占位参数目前没什么用，要注意它也算参数，调用函数时要传值。
        3. 函数的重载 1 同一作用域 2 函数名相同 3 参数 顺序 或者 个数 或者 类型不同 4 返回值类型不作为条件, 重载要主要二义性，比如 参数 int a int & a const int & a 同时为3个函数的参数，传递变量时,
          1与2冲突 传递数值时 2与3冲突
        4. extern 1可以用在c++调用文件外const类型，2 c语言的函数被c++调用时，因为解析函数名的方式不一样，比如c中 void func()在c++中用func()无法调用，要加extern "c" {void func()} ，函数比较多时，
          但有一个方便的方式，在c语言头文件中加#ifdef __cpulsplus   extern "c"  {                             #if def __cpulsplus  }
        5. 
      
  
