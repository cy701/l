# l
my new learn learn about c and c++
### 第一天 
  #### XOR的学习 xor_link
  XOR即异或运算，快速算法为不进位的加法运算，我从老师那里得知两个xor我使用技巧
  ** 第一个技巧：
  110^011=101 101^011=110 ，我们发现一个规律，如果a^b=c 那么 c^b=a 观察这两个式子，如果把a代入到第一个式子，会得到c^b^b=c，
  因为c与一个数进行运算等于本身，我们可以把b^b看成幺元，实际上，无论多少个相同的数进行xor运算都相当于幺元，如果a^b=N（N是一个未知的变量）
  那么如何求b，根据上面的结论，只需在a的左侧^a，后来我知道了异或运算是不先后顺序的，所以a可以在任意位置，所以b=N^a。进一步想一下，一个链表
  中有a,b,c三个数，只有a,b两个数被分配了地址，如果我们把c=a^b，将c也分配了地址，此时这三个数有一定的规律，知道其中两个数，可以快速得到第三数
  这是一个巨大的发现，因为我们可以根据地址快速找到第三个数的地址，这意味着这个链表可以任意方向的遍历，这就是异或链表。
  ** 第二个技巧：
  上面我们知道a^a^a...无论多少个a，都是幺元，我们可以快速查找到一堆数中的不同的数，并得到它的值
  #### 汇编内中断的学习
  ** 我学习王爽的汇编的内中断 我们来修改0号内中断程序的代码，该内中断为除0异常中断（但不是所有的中断都是异常），它触发了int + 编号 指令,编号是对应中断向量表中对应中断例程的内存地址，
      我们可以修改该内存地址的内容来达到修改中断例程的目的。下面我们来写一个0中断，有除0错误时，显示错误信息在屏幕上，这个程序叫do0
      *** 安装，写入内存，我们用到了rep movsb指令，该指令可以把代码放在特定的内存位置，该指令上面必须要有4个准备，1 设置 es:di 为目的地址， （es为段寄存
      中没有什么存在感的寄存器，di是有关堆栈的，它和si都没有什么存在感，是作为偏移地址，但重要的是，di,si,bx,bp,只能用这4个寄存器作偏移，bx是内存偏移，bp是堆栈偏移，用来代替sp取局
      部变量，di,si只在段偏移的时候见过）。2 设置 ds:si为源地址（ds是4个段寄存器之一，和内存有关，[]前面默认就是这个，要说的是，段寄存器隐藏很深，你读不到它的全貌，写也是修改其中一小部分
      3 设置cx 为传输长度 （cx和计数有关，但不要和程序计数器混淆，pc是记录的是下一条指令的地址，还有sepc是内核的程序计数器，在进行系统调用切换状态的时候，还有另一些有关内核的东西会用到），
      4 把传输方向改成正方向（不懂）用cld指令 进行完这四个操作后，执行rep movsb指令
      我们可以把想要的东西写入内存中了
      *** 设置中断向量表，将上面的内存地址写入向量表中，0号表项地址为0:0,0:0存放偏移地址，0:2存放段地址，相差2字节是因为地址是1字单元地址，但我不知道为什么先放偏移再放段地址。
      *** 将信息显示在屏幕上，mov ax,4c00h ax为4c00h时，再执行int 21h中断会将内容显示在屏幕上，这涉及到了显示器中断，将不同的寄存器存入对应的值会有不同的效果，比如说鼠标移动，
          在鼠标位置显示字符等等。
      *** do0 的取出字符串并显示在屏幕上，字符串上面要加短跳转，（短跳转一般用于循环，判断的跳转，这些距离都很短），跳到下面的正式代码，设置ds si，取出字符串，偏移要加2，
          （因为我们需要找到字符串，字符串上面有一行代码，要在目的地址加2，目的地址是我们上面写好的地址）,设置es:di，显示在屏幕上 设置字符串长度cx，然后写一个函数来循环取出字符串变量，
          显示在屏幕上 mov ax,4c00h  int 21h  
      
  
